#!/usr/bin/env python3
"""
Enhanced Git Hooks Installation - Prevents CodeQL Issues at Commit Time

This script installs comprehensive git hooks that run our enhanced quality gate
to catch CodeQL-style issues before they reach CI/CD.

Usage:
    python tools/automation/install-enhanced-git-hooks.py
    python tools/automation/install-enhanced-git-hooks.py --force    # Override existing hooks
"""

import os
import stat
import argparse
from pathlib import Path


def create_pre_commit_hook(git_hooks_dir: Path) -> bool:
    """Create pre-commit hook that runs enhanced quality gate"""

    hook_content = """#!/bin/bash
# Enhanced Pre-Commit Hook - Catches CodeQL Issues Locally
# Generated by AI-First SDLC Framework

set -e

echo "üîç Running Enhanced Pre-Commit Quality Gate..."

# Check if we have staged Python files
STAGED_PYTHON_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.py$' || true)

if [ -z "$STAGED_PYTHON_FILES" ]; then
    echo "‚úÖ No Python files staged, skipping quality gate"
    exit 0
fi

echo "üìã Python files to validate:"
echo "$STAGED_PYTHON_FILES" | sed 's/^/  - /'

# Run syntax check first (fast)
echo "
üêç Running Python syntax check..."
if ! python tools/validation/local-validation.py --syntax; then
    echo "‚ùå Syntax errors found. Fix these first:"
    exit 1
fi

# Run CodeQL-style analysis on staged files
echo "
üîç Running CodeQL-style analysis..."
if ! python tools/validation/pre-push-quality.py --codeql; then
    echo "‚ùå Static analysis found issues. Fix these before committing."
    echo "üí° Tip: Run the full analysis with --verbose for detailed suggestions"
    exit 1
fi

# Run quick validation
echo "
‚ö° Running quick validation..."
if ! python tools/validation/local-validation.py --quick; then
    echo "‚ùå Quick validation failed. Review issues above."
    exit 1
fi

echo "‚úÖ All pre-commit checks passed!"
exit 0
"""

    hook_path = git_hooks_dir / "pre-commit"

    try:
        with open(hook_path, "w") as f:
            f.write(hook_content)

        # Make executable
        os.chmod(hook_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)

        print(f"‚úÖ Created pre-commit hook: {hook_path}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to create pre-commit hook: {e}")
        return False


def create_pre_push_hook(git_hooks_dir: Path) -> bool:
    """Create pre-push hook that runs comprehensive quality gate"""

    hook_content = """#!/bin/bash
# Enhanced Pre-Push Hook - Comprehensive Quality Gate
# Generated by AI-First SDLC Framework

set -e

echo "üöÄ Running Enhanced Pre-Push Quality Gate..."

# Run comprehensive validation including CodeQL-style analysis
if ! python tools/validation/pre-push-quality.py; then
    echo "
‚ùå Pre-push quality gate failed!"
    echo "
üîß Fix suggestions:"
    echo "  1. Run: python tools/validation/pre-push-quality.py --verbose"
    echo "  2. Fix all errors and warnings"
    echo "  3. Run: python tools/validation/local-validation.py --pre-push"
    echo "  4. Try pushing again"
    echo "
üí° These checks mirror CI/CD validation - fixing them locally saves time!"
    exit 1
fi

echo "‚úÖ All pre-push checks passed - ready to push!"
exit 0
"""

    hook_path = git_hooks_dir / "pre-push"

    try:
        with open(hook_path, "w") as f:
            f.write(hook_content)

        # Make executable
        os.chmod(hook_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)

        print(f"‚úÖ Created pre-push hook: {hook_path}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to create pre-push hook: {e}")
        return False


def create_commit_msg_hook(git_hooks_dir: Path) -> bool:
    """Create commit-msg hook that validates commit message format"""

    hook_content = """#!/bin/bash
# Commit Message Validation Hook
# Generated by AI-First SDLC Framework

COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Check for conventional commit format
if ! echo "$COMMIT_MSG" | grep -qE '^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\\(.+\\))?!?: .+'; then
    echo "‚ùå Invalid commit message format!"
    echo "
üìã Required format: type(scope): description
Examples:
  feat(api): add user authentication
  fix(validation): correct argument count in save_context
  docs(readme): update installation instructions
  refactor(tools): extract CodeQL analyzer class
"
    exit 1
fi

# Check minimum length
if [ ${#COMMIT_MSG} -lt 10 ]; then
    echo "‚ùå Commit message too short (minimum 10 characters)"
    exit 1
fi

# Check maximum length for first line
FIRST_LINE=$(echo "$COMMIT_MSG" | head -1)
if [ ${#FIRST_LINE} -gt 72 ]; then
    echo "‚ùå First line too long (maximum 72 characters, got ${#FIRST_LINE})"
    exit 1
fi

echo "‚úÖ Commit message format valid"
exit 0
"""

    hook_path = git_hooks_dir / "commit-msg"

    try:
        with open(hook_path, "w") as f:
            f.write(hook_content)

        # Make executable
        os.chmod(hook_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)

        print(f"‚úÖ Created commit-msg hook: {hook_path}")
        return True

    except Exception as e:
        print(f"‚ùå Failed to create commit-msg hook: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Install enhanced git hooks for quality gate"
    )
    parser.add_argument("--force", action="store_true", help="Override existing hooks")

    args = parser.parse_args()

    # Find git directory
    git_dir = Path(".git")
    if not git_dir.exists():
        print("‚ùå Not in a git repository")
        return 1

    hooks_dir = git_dir / "hooks"
    hooks_dir.mkdir(exist_ok=True)

    print("üîß Installing Enhanced Git Hooks for AI-First SDLC...")
    print(f"Location: {hooks_dir}")

    # Check for existing hooks
    existing_hooks = []
    for hook_name in ["pre-commit", "pre-push", "commit-msg"]:
        hook_path = hooks_dir / hook_name
        if hook_path.exists():
            existing_hooks.append(hook_name)

    if existing_hooks and not args.force:
        print(f"‚ö†Ô∏è  Existing hooks found: {', '.join(existing_hooks)}")
        print("Use --force to override existing hooks")
        response = input("Continue and backup existing hooks? [y/N]: ")
        if response.lower() != "y":
            print("Aborted")
            return 1

        # Backup existing hooks
        for hook_name in existing_hooks:
            hook_path = hooks_dir / hook_name
            backup_path = hooks_dir / f"{hook_name}.backup"
            hook_path.rename(backup_path)
            print(f"üì¶ Backed up {hook_name} to {hook_name}.backup")

    # Install hooks
    success_count = 0

    if create_pre_commit_hook(hooks_dir):
        success_count += 1

    if create_pre_push_hook(hooks_dir):
        success_count += 1

    if create_commit_msg_hook(hooks_dir):
        success_count += 1

    separator = "=" * 50
    print(f"\n{separator}")
    print("üéØ Enhanced Git Hooks Installation Summary")
    print(separator)

    if success_count == 3:
        print("‚úÖ All hooks installed successfully!")
        print("\nüìã Installed hooks:")
        print("  ‚Ä¢ pre-commit: Syntax + CodeQL-style analysis")
        print("  ‚Ä¢ pre-push: Comprehensive quality gate")
        print("  ‚Ä¢ commit-msg: Conventional commit format")
        print("\nüí° Benefits:")
        print("  ‚úì Catches CodeQL issues before CI/CD")
        print("  ‚úì Enforces consistent code quality")
        print("  ‚úì Prevents push-fail-fix cycles")
        print("  ‚úì Validates commit message format")
        print("\nüöÄ Ready! Your next commit will run enhanced validation.")
        return 0
    else:
        print(f"‚ö†Ô∏è  Only {success_count}/3 hooks installed successfully")
        print("Check error messages above for details")
        return 1


if __name__ == "__main__":
    exit(main())
